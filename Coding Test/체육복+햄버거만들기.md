
[체육복]

#1. 탐욕법



[햄버거 만들기]
#1. Arrays.asList()
`Arrays.asList()` 메서드는 배열을 고정 크기의 리스트로 변환합니다. 이는 원래 배열과 같은 객체를 참조하기 때문에 배열의 요소를 변경하면 해당 리스트에도 반영됩니다. 그러나 기본 데이터 유형 배열 (예: `int[]`, `double[]`, `char[]` 등)을 `Arrays.asList()`로 변환하면 원시 타입이 아닌 배열을 포함한 리스트를 생성합니다. 이는 원시 타입 배열을 포장한 객체 배열로 간주되기 때문에 원시 타입이 아닌 기본 데이터 유형을 가진 리스트를 얻게 됩니다.

따라서 `Arrays.asList()`를 사용하여 기본 데이터 유형 배열을 리스트로 변환하면 원시 타입이 아닌 리스트를 얻게 되므로 원시 타입 배열을 사용하는 경우에는 적절하지 않습니다. 대신에 원시 타입 배열의 요소를 직접 반복하여 리스트에 추가하거나, Java 8부터는 `IntStream`을 사용하여 `Arrays.stream()` 메서드로 배열을 스트림으로 변환하고 `boxed()` 메서드로 각 요소를 박싱하여 스트림을 `List<Integer>`로 변환하는 방법을 사용할 수 있습니다.

+
`Arrays.asList()` 메서드는 기본 데이터 유형의 배열을 리스트로 변환할 수 있지만, 기본 데이터 유형에 대한 리스트를 반환하는 것이 아니라 `List<int[]>`를 반환합니다. 이러한 이유로 `List<Integer>`가 아닌 `List<int[]>` 형식으로 `list` 변수를 설정하려고 시도했기 때문에 컴파일 오류가 발생합니다.

대신에 `Arrays.asList()` 메서드를 사용하여 배열을 리스트로 변환하면 기본 데이터 유형 대신 `Integer` 객체로 박싱되어야 합니다.


so, for문 대신에 
기본 데이터 유형 배열을 `List<Integer>`로 변환하는 더 간단한 방법은 Apache Commons 라이브러리의 `ArrayUtils.toObject()` 메서드를 사용하는 것입니다. 이 방법을 사용하면 배열을 기본 데이터 유형의 박싱된 객체 배열로 변환할 수 있습니다. 그런 다음 Java 8에서 `Arrays.asList()` 메서드를 사용하여 해당 객체 배열을 `List<Integer>`로 변환할 수 있습니다.

import org.apache.commons.lang3.ArrayUtils;
import java.util.Arrays;
import java.util.List;

class Solution {
    public int solution(int[] ingredient) {
        int answer = 0;
        
        // 기본 데이터 유형 배열을 객체 배열로 변환
        Integer[] boxedArray = ArrayUtils.toObject(ingredient);
        
        // 객체 배열을 List<Integer>로 변환
        List<Integer> list = Arrays.asList(boxedArray);
        
        // 리스트를 사용하여 작업 수행
        for (int i = 0; i < list.size() - 3; i++) {
            System.out.println(list.get(i));
            // 작업 수행
        }
        
        return answer;
    }
}
이 코드에서 `ArrayUtils.toObject()` 메서드는 기본 데이터 유형 배열을 객체 배열로 변환하고, `Arrays.asList()` 메서드는 객체 배열을 `List<Integer>`로 변환합니다. 이렇게 하면 `List<Integer>`을 사용하여 배열을 반복할 수 있습니다.


or
다른 방법으로는 Java 8의 스트림 API를 사용하여 배열을 리스트로 변환하는 방법이 있습니다. 스트림 API는 배열의 요소를 스트림으로 변환하고 이를 리스트로 수집할 수 있습니다.
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class Solution {
    public int solution(int[] ingredient) {
        int answer = 0;
        
        // 배열을 리스트로 변환
        List<Integer> list = Arrays.stream(ingredient)
                                   .boxed() // 기본 데이터 유형을 박싱된 객체로 변환
                                   .collect(Collectors.toList());
        
        // 리스트를 사용하여 작업 수행
        for (int i = 0; i < list.size() - 3; i++) {
            System.out.println(list.get(i));
            // 작업 수행
        }
        
        return answer;
    }
}
이 코드에서 `Arrays.stream(ingredient)`은 배열을 스트림으로 변환하고, `boxed()` 메서드는 기본 데이터 유형을 박싱된 객체로 변환합니다. 마지막으로 `collect(Collectors.toList())`를 호출하여 스트림을 리스트로 수집합니다. 이렇게 하면 리스트를 사용하여 배열을 반복할 수 있습니다.


#2 
del은 원소를 지우고 끝나는게 아니라 지운 원소의 인덱스를 채우기 위해서 뒤의 원소들의 인덱스들을 1씩 줄여야 합니다. 그래서 list의 길이가 길어지면 그만큼 걸리는 시간도 늘어나게 됩니다. 확인해 보면 시간 초과 뜨는 테스트케이스들의 ingredient의 길이가 20만 이상이더군요. 최대 길이가 100만인데 20만에서부터 시간 초과가 뜨는 거 보면 생각보다 시간이 더 많이 걸리나 봅니다. 시간 복잡도에 대해서 찾아보세요.


정확성은 통과하셨다고 하니 시간초과에 대한 힌트를 드리자면  
[List의 remove는 O(N)](https://codingdog.tistory.com/entry/java-ArrayList-remove-%EB%A9%94%EC%86%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B4%85%EC%8B%9C%EB%8B%A4#:%7E:text=173%EC%B4%88%2C%202%EB%B6%84%2053%EC%B4%88%EA%B0%80%20%EA%B1%B8%EB%A6%BD%EB%8B%88%EB%8B%A4.%20%EC%9D%B4%EB%8A%94%20%EB%A3%A8%ED%94%84%EB%A7%88%EB%8B%A4%20O%20%28size%29%EC%9D%98,%EC%A0%9C%EA%B1%B0%ED%95%A0%20%EC%9B%90%EC%86%8C%EB%93%A4%EC%9D%84%20Collection%EC%97%90%EB%8B%A4%20%EB%84%A3%EC%96%B4%EC%84%9C%20removeAll%EC%97%90%20%EB%84%98%EA%B2%A8%EC%A3%BC%EB%8A%94%20%EB%B0%A9%EB%B2%95%EB%8F%84%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.) 이 소요됩니다.  
해당 문제는 스택 자료구조를 사용하시거나 충분히 큰 array를 선언해 두시고 인덱스만 적절히 관리하면서 풀이하셔도 됩니다.

#3. stack ???
햄버거자체가 stack 이래.. 뭘?까..


[달리기 경주]
#!. 메소드의 시간 복잡도에 대해서 찾아보세요.
++ 해당 문제는 해시를 사용하는 문제이고,  
2개의 해시 변수를 사용하여, 문제를 O(N+M)으로 풀어낼 수 있습니다.
++ List에 현재 등수를 저장하고 .indexOf() 메소드를 사용하여 callings 대상의 인덱스를 찾는 경우 배열을 순회하며 찾기때문에 크기가 커지는 만큼 시간복잡도가 늘어납니다.  
따라서 HashMap에 저장 후 .get() 메소드를 사용하여 callings 대상의 현재 인덱스를 바로 찾아 Array에 반영하고 HashMap에도 수정된 등수를 반영하여 Array와 HashMap을 동기화하는 방식의 반복을 통해 마지막 callings 까지 처리한다면 타임아웃 없이 해결 가능합니다.
 ++ 알고리즘문제는 통상적으로 1초안에 해결해야합니다.  
  
언어에 따라 연산속도가 다르지만 대부분 기준을 1초에 10억번 연산으로 잡습니다.

players의 최대길이 50000,  
callings의 최대길이 100000

indexOf 메소드 => 사용시 5만 사용 // O(N)  
splice 메소드 => 사용시 5만 사용 // O(N)

해당 코드는 calings의 요소 한번마다 150000번에 연산을 사용함.  
따라서 100000 * 150000 => 15000000000번에 연산 .  
10억이 넘어가므로 시간초과.

시간복잡도에대해 공부해보시는걸 추천합니당.



#2, 
배열을 복사하는 방법은 몇 가지가 있습니다. 여기에는 배열을 새로운 배열에 복사하는 여러 가지 방법이 포함됩니다.

1. **for 루프를 사용하여 수동으로 복사하기**: 이 방법은 가장 기본적이고 직관적인 방법입니다. 원래 배열의 각 요소를 새 배열에 복사합니다.

javaCopy code

`String[] originalArray = {"a", "b", "c"}; String[] newArray = new String[originalArray.length]; for (int i = 0; i < originalArray.length; i++) {     newArray[i] = originalArray[i]; }`

2. **System.arraycopy() 메서드 사용하기**: System 클래스의 arraycopy() 메서드를 사용하여 배열을 복사할 수 있습니다.

javaCopy code

`String[] originalArray = {"a", "b", "c"}; String[] newArray = new String[originalArray.length]; System.arraycopy(originalArray, 0, newArray, 0, originalArray.length);`

3. **Arrays.copyOf() 메서드 사용하기**: Arrays 클래스의 copyOf() 메서드를 사용하여 배열을 복사할 수 있습니다.

javaCopy code

`String[] originalArray = {"a", "b", "c"}; String[] newArray = Arrays.copyOf(originalArray, originalArray.length);`

이러한 방법 중에서 선택할 수 있습니다. 원하는 방법을 선택하여 사용하시면 됩니다!