# JAVA에서 Node.js로 바꾸는 이유와 Node.js 기초 정리

## 1. 소개

### 왜 이 공부를 하게 되었는가

- 실무 및 주변 개발 환경에서 Node.js 사용 비중이 계속 늘어나고 있어 직접 경험해보고 싶었다.
- Flutter 기반 앱 개발을 진행하면서, 화면 중심으로 빠르게 변하는 Flutter와 도메인 중심의 Java(Spring) 백엔드 사이에 **개발 템포 차이**를 명확하게 체감했다.

이 템포 불일치는 Node.js를 공부하게 된 가장 큰 계기였다.

---

## 2. Flutter ↔ Java 개발 템포 차이

### Flutter의 프론트엔드 특성
- 화면(UI) 중심 구조
- 화면 요구사항이 잦은 변경
- API가 도메인 중심이 아닌 **뷰 단위**
- 네트워크 상황에 민감
- 실시간 및 비동기 이벤트가 많음

Flutter가 백엔드에 기대하는 것은  
**“단단함”보다는 “유연함과 빠른 반응성”** 이었다.

### Java(Spring)의 백엔드 특성
- 도메인 모델 → 서비스 → API 구조
- Entity 안정성, 규칙 관리에 강점
- 변경에 보수적인 구조

Flutter 화면이 변경될 때마다:
- DTO 수정
- Mapper 수정
- 여러 계층에 영향 발생

이로 인해 **빠르게 변하는 Flutter UI와 Java 백엔드의 개발 템포가 맞지 않는다는 느낌**을 받았다.

### 데이터 모델링 방식의 차이

- Flutter ↔ Node.js  
  `JSON → JSON → JSON`
- Flutter ↔ Java  
  `JSON → DTO → Entity → DTO → JSON`

중간 계층이 줄어들수록 모바일 API 개발 속도는 빨라진다.

또한 Flutter는 **UI를 위한 데이터**가 필요하고,  
Node.js는 이를 JSON 중심으로 바로 만들어줄 수 있다는 점도 매력적으로 느껴졌다.

| 항목 | Java | Node.js |
| --- | --- | --- |
| API 변경 속도 | 느림 | 빠름 |
| 화면 맞춤 API | 불편 | 매우 편함 |
| 실시간 처리 | 무거움 | 자연스러움 |
| 서버 자원 | 상대적 무거움 | 가벼움 |
| 모바일 대응 | 보수적 | 유연 |

복잡한 비즈니스 도메인이 아닌,  
**지속적인 리뉴얼이 예정된 앱 구조에서는 Node.js가 더 적합하다고 판단했다.**

---

## 3. Node.js란 무엇인가

Node.js는 **브라우저 밖에서 JavaScript를 서버에서 실행할 수 있게 해주는 런타임**이다.

- 언어: JavaScript (또는 TypeScript)
- 엔진: V8 (Chrome에서 사용하는 엔진)
- 목적: **I/O가 많은 서버 작업을 빠르고 가볍게 처리**

Node.js의 핵심은  
**속도, 생산성, 그리고 강력한 생태계**다.

---

## 4. Node.js의 장점

### 4.1 실행 모델
- 이벤트 루프 기반
- 논블로킹 I/O 구조
- 단일 스레드로 수천 개 요청 처리 가능

I/O 작업이 많은 웹 서버 환경에서 매우 효율적이며,  
Node.js는 대표적인 **이벤트 기반 서버 엔진**이다.

### 4.2 싱글 스레드 + 논블로킹 구조

웹 서버의 대부분 작업은 다음과 같다.
- DB 호출
- 외부 API 요청
- 파일 업로드
- 결제 처리

CPU 연산보다 **I/O 작업 비중이 압도적으로 높다**.

Java:
- 요청당 스레드 할당
- 스레드 풀 관리 필요
- 트래픽 증가 시 메모리 부담 증가

Node.js:
- 싱글 스레드
- I/O 작업은 논블로킹 처리
- 하나의 스레드로 다수 요청 처리

Flutter 앱의 API 요청 대부분이 I/O 작업이기 때문에  
Node.js 구조와 잘 맞는다.

### 4.3 이벤트 루프 개념

Node.js는 다음과 같은 방식으로 동작한다.

`요청 수신 → 오래 걸리는 작업(DB, API)은 맡겨두고 → 완료되면 이벤트로 처리`

작업을 기다리며 멈춰 있지 않기 때문에  
Flutter 클라이언트 요청 처리 효율이 높다.

### 4.4 JSON 친화적인 서버

Node.js의 기본 사고 방식은 다음과 같다.

`입력(JSON) → 처리(함수) → 출력(JSON)`

Flutter와 데이터 구조가 자연스럽게 맞아떨어진다.

### 4.5 npm 생태계

npm 생태계는 매우 방대하다.
- 결제
- 인증
- 이미지 처리
- 로깅
- 큐
- 크롤링
- AI 연동

대부분의 기능을  
`npm install` 한 번으로 바로 사용할 수 있다.

Java의 Maven/Gradle도 강력하지만,  
**속도와 선택지의 폭에서는 npm이 더 유연하다고 느꼈다.**

---

## 5. Java 개발자가 Node.js를 사용하며 달라지는 점

### 사고방식의 변화

| Java | Node.js |
| --- | --- |
| 객체 중심 | 흐름 중심 |
| 동기 사고 | 비동기 사고 |
| 설계 우선 | 실행 우선 |

- OOP 중심 사고 → 이벤트 및 함수 중심 사고
- 동기 처리 기준 → 비동기 처리 기준

Java는  
`안정적 / 무겁고 / 규칙이 많음`

Node.js는  
`자유롭고 / 빠르고 / 가볍지만 / 책임은 개발자에게 있음`

---

## 6. 깨달은 점

- Java(Spring)는 도메인 규칙이 명확하고 안정성이 중요한 서비스에 강점이 있다.
- 반대로, Flutter처럼 **UI 변화가 잦고 빠른 피드백이 중요한 앱**에서는 Node.js가 개발 흐름에 더 잘 맞을 수 있다.
- 백엔드는 항상 프론트엔드보다 “단단해야 한다”고 생각했지만,  
  상황에 따라서는 **유연함과 반응성이 더 큰 가치가 될 수 있다는 점**을 깨달았다.
- 결국 중요한 것은 특정 기술에 익숙해지는 것이 아니라,  
  **현재 문제에 가장 적합한 도구를 선택할 수 있는 판단력**이라는 생각이 들었다.

--- 
## 작성일
- 2026-02-03
