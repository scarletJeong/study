# 조합과 동적 계획법(DP): 차이점 및 구현 사례

## 소개

문제를 해결하는 과정에서 조합과 동적 계획법(DP)의 차이점과 활용법에 대해 학습하게 되었음.     
특히, DP를 이용한 최적화 기법이 조합보다 효율적이라는 점을 이해하며, 
조합과 DP의 개념, 차이점, 그리고 자바를 활용한 DP 구현 사례를 정리함.

---

## 1. 조합(Combination)과 동적 계획법(DP)의 차이점

### 조합(Combination)
- **정의**:
  - n개의 항목 중 r개의 항목을 선택하는 경우의 수를 계산하는 기법.
  - 수학적으로 팩토리얼을 기반으로 계산: `nCr = n! / (r! * (n-r)!)`

- **단점**:
  1. **팩토리얼 연산의 오버플로**:
     - 팩토리얼 값이 빠르게 커지며, 큰 숫자를 처리할 때 오버플로 문제가 발생할 수 있음.
  2. **복잡한 구현**:
     - 추가적인 나머지 연산 및 조합 계산이 필요하여 구현이 복잡해질 수 있음.

### 동적 계획법(Dynamic Programming, DP)
- **정의**:
  - 복잡한 문제를 작은 하위 문제로 나누고, 이전 계산 결과를 재사용하여 효율적으로 해결하는 기법.

- **장점**:
  1. **효율적인 계산**:
     - 이전 결과를 재사용하여 중복 계산을 방지.
  2. **메모리 최적화 가능**:
     - 문제에 따라 전체 배열이 아닌 필요한 값만 저장.

---

## 2. DP를 활용해 문제풀이

### 문제 설명

### 최적화된 DP 로직
 
1. **초기값**:
   - `dp[1] = 1`: 1칸에 도달하는 방법은 1가지.
   - `dp[2] = 2`: 2칸에 도달하는 방법은 2가지.
  
2. **점화식**:
  - `dp[i] = dp[i-1] + dp[i-2]`
    - `dp[i-1]`: 이전 칸에서 한 칸 이동한 경우.
    - `dp[i-2]`: 두 칸 전에서 두 칸 이동한 경우.

3. **최적화**:
   - 전체 DP 배열 대신 이전 두 값만 저장하여 메모리 사용량을 줄임.


---

## 코드 설명

1. **초기값 설정**:
   - `n=1` 또는 `n=2`일 경우 바로 결과 반환.

2. **점화식 구현**:
   - `dp[i] = dp[i-1] + dp[i-2]`를 적용하며, 이전 두 값만 저장하여 메모리 최적화.

3. **모듈 연산 적용**:
   - 값의 범위를 제한하고 오버플로를 방지하기 위해 **%1234567**을 적용.
     
4. **결과 반환**:
   - 최종적으로 계산된 `current` 값을 반환.

---

## 시간 및 공간 복잡도

1. **시간 복잡도**:
   - `O(n)`: n칸에 도달하기 위해 한 번의 루프를 순회.

2. **공간 복잡도**:
   - `O(1)`: DP 배열 대신 이전 두 값만 저장.

---

## 실행 예제

- 입력: `n = 4`

  | i  | dp[i] 계산          | dp 값  |
  |----|---------------------|--------|
  | 1  | 1                   | 1      |
  | 2  | 2                   | 2      |
  | 3  | 1 + 2               | 3      |
  | 4  | 2 + 3               | 5      |

- 출력: `5`

---
## 추가 :  왜 **%1234567**하는 거지?
1. 오버플로 방지
   - dp[i] = dp[i-1] + dp[i-2] 형태의 점화식에서 dp[i-1]과 dp[i-2]의 값이 커지면, dp[i]도 매우 큰 값이 됨.   
   - Java에서 long 자료형은 약 19자리(최대 9,223,372,036,854,775,807)까지 저장할 수 있지만, 특정 문제에서는 계산 중 값이 이를 초과할 수 있움.   

2. 범위 내에서 표현하도록 유도
   - 많은 알고리즘 문제에서 결과를 특정 수로 나눈 나머지를 요구하는 경우가 많은데, 이는 정답이 너무 커질 수 있으므로, 이를 제한된 범위 내에서 표현하도록 유도함.
   - 예를 들어, 1234567로 나눈 나머지를 반환하면 정답이 항상 0 ≤ 정답 < 1234567 범위에 있음.

3. 연산 효율성
   - 큰 수의 연산은 일반적으로 더 많은 시간과 메모리를 소모합니다.
   - %1234567를 사용하면 값이 작아져 연산 속도가 빨라지고, 메모리 소모도 줄어듭니다.

       
---

## 깨달은 점

1. **조합보다 동적 계획법이 적합한 이유**:
   - 팩토리얼 연산으로 인한 오버플로 문제를 방지하며, 구현이 간단하고 효율적임.

2. **메모리 최적화의 중요성**:
   - DP 배열 대신 필요한 값만 저장하여 메모리 사용량을 줄일 수 있음을 학습함.

3. **점화식의 활용**:
   - 문제를 하위 문제로 나누고, 반복 계산을 줄이는 전략의 효과를 경험함.
