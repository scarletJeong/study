1. 비 static 메서드 'getUserResult(java. lang. String)'은(는) static 컨텍스트에서 참조할 수 없습니다 

>	- **정적(static) 메서드나 정적 블록 내에서 인스턴스(비-static) 메서드를 호출하려고 할 때** 발생
>	- `static` 메서드는 클래스의 인스턴스와 무관하게 클래스 레벨에서 호출됩니다. 반면, 인스턴스 메서드는 특정 객체(인스턴스)와 연결되어 있어야 호출할 수 있습니다. 정적 메서드 내에서 비-static 메서드를 호출하려고 하면, 어떤 인스턴스를 사용해야 할지 알 수 없기 때문에 컴파일 오류가 발생합니다.
>	- .
>	- >
>	- 1. `UserService` 클래스의 인스턴스를 먼저 생성한 후 호출할 수 있습니다.
>	- 2. 메서드를 `static`으로 변경하기
>		- 만약 `getUserResult` 메서드를 인스턴스가 아닌 클래스 레벨에서 호출할 수 있도록 하고 싶다면, `getUserResult` 메서드를 `static`으로 선언합니다.


>여기서 발생하는 문제는 `UserService.getUserResult(email)` 호출 부분입니다. `UserService` 클래스에서 `getUserResult` 메서드가 **비-static 메서드**일 때, 정적(static) 방식으로 호출하려 해서 에러가 발생합니다.

### 문제 분석

`UserService.getUserResult(email)`에서 `getUserResult`를 `static` 메서드처럼 호출하고 있는데, `getUserResult`가 비-static 메서드로 정의되어 있다면 `UserService` 인스턴스를 통해 호출해야 합니다.

### 해결 방법

1. **인스턴스를 사용하여 호출하기**
    
    `getUserResult` 메서드를 호출하려면 `UserService`의 인스턴스를 생성하거나, 이미 주입된 `userService` 인스턴스를 통해 호출해야 합니다. 이 코드는 이미 `userService`를 주입받고 있으므로, 이를 사용해 호출할 수 있습니다.
    
    java
    
    코드 복사
    
    `@Operation(summary = "사용자 결과 보기", description = "사용자 건강보고서 결과 보기 _ 미완성") @GetMapping("/get-user-results") public ResponseEntity<ApiResponse<List<Object>>> getUserResult(@RequestParam String token, @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date date) {      String email = userService.findByToken(token).getEmail();      // 기존 static 호출 방식 제거하고, 주입된 userService 인스턴스 사용     List<Object> getUserResults = userService.getUserResult(email);      return ResponseEntity.ok(new ApiResponse<>(getUserResults, "Success")); }`
    
2. **`getUserResult` 메서드를 `static`으로 변경하기**  
    `UserService.getUserResult`를 정적 메서드로 사용해야 하는 경우에는, `getUserResult` 메서드를 `static`으로 선언해야 합니다.
    
    그러나 **주로 비즈니스 로직을 포함한 서비스 메서드는 인스턴스 메서드로 사용하는 것이 일반적**이므로, 가능하면 첫 번째 방법(인스턴스를 통해 호출)을 사용하는 것이 좋습니다.
    

이렇게 수정하면 `NullPointerException` 없이 `userService`의 `getUserResult` 메서드를 올바르게 호출할 수 있습니다.



여기서 바뀌는 부분은 **`getUserResult` 메서드 호출 방식**입니다. 기존에는 `UserService.getUserResult(email)` 방식으로 호출하여 `static` 메서드처럼 사용하려 했지만, 이 방식은 오류를 발생시킵니다. **해결책은 `userService` 인스턴스를 통해 호출하는 것**입니다.

### 코드 전후 비교

#### 수정 전 코드

java

코드 복사

`List<Object> getUserReults = UserService.getUserResult(email);`

이 코드는 `UserService` 클래스의 `getUserResult` 메서드를 `static` 방식으로 호출하는 코드입니다. 하지만 `getUserResult`가 비-static 메서드일 경우 이렇게 호출할 수 없으므로 오류가 발생합니다.

#### 수정 후 코드

java

코드 복사

`List<Object> getUserResults = userService.getUserResult(email);`

수정 후에는 `userService`라는 **이미 주입된 `UserService` 인스턴스를 통해 호출**합니다. 이렇게 하면 `getUserResult` 메서드를 `static`으로 선언할 필요 없이 호출할 수 있습니다.

### 요약

- **수정 전**: `UserService.getUserResult(email)` - `static` 방식 호출 (오류 발생).
- **수정 후**: `userService.getUserResult(email)` - `userService` 인스턴스 통해 호출 (오류 해결).

이제 `getUserResult` 메서드가 **비-static 메서드**인 경우에도 문제없이 호출됩니다.




2. The dependencies of some of the beans in the application context form a cycle:

   bloodPressureRecordController defined in file [C:\source\build\classes\java\main\com\repure\purewithme\domain\bloodpressure\controller\BloodPressureRecordController.class]
┌─────┐
|  userService defined in file [C:\source\build\classes\java\main\com\repure\purewithme\domain\user\service\UserService.class]
└─────┘

> 이거 UserService.java 파일에서 userService를 정의하고 사용해서 그럼. 



3. DTO 파일에서 import lombok.Data ?
> `import lombok.Data`는 **Lombok 라이브러리**의 `@Data` 어노테이션을 임포트하는 것입니다. Lombok은 Java에서 반복되는 코드를 줄여주는 라이브러리로, `@Data`는 **클래스에 여러 유용한 메서드를 자동으로 생성**하는 역할을 합니다.

`@Data` 어노테이션의 기능

`@Data`는 다음 기능을 한 번에 포함하는 종합적인 어노테이션입니다:

1. **Getter 메서드 자동 생성**: 클래스의 모든 필드에 대해 `getter` 메서드를 생성합니다.
2. **Setter 메서드 자동 생성**: 클래스의 모든 비-`final` 필드에 대해 `setter` 메서드를 생성합니다.
3. **`toString()` 메서드 자동 생성**: 객체의 모든 필드 값을 포함한 `toString()` 메서드를 생성합니다.
4. **`equals()` 및 `hashCode()` 메서드 자동 생성**: 객체 비교와 해시 코드를 위한 `equals()`와 `hashCode()` 메서드를 생성합니다.
5. **`@RequiredArgsConstructor` 자동 생성**: `final`이나 `@NonNull`로 표시된 필드를 포함하는 생성자를 생성합니다.

위 코드에서 `@Data` 어노테이션 덕분에 `User` 클래스에는 `getter`, `setter`, `toString()`, `equals()`, `hashCode()` 메서드가 자동으로 추가됩니다. 이를 통해 반복되는 코드를 줄이고, 더 간결한 코드를 작성할 수 있습니다.

`@Data`의 장점과 주의점

- **장점**: 필드가 많을 때 유용하며, 코드 가독성과 유지보수를 용이하게 합니다.
- **주의점**: 클래스의 모든 필드에 대해 `getter`와 `setter`가 생성되므로, 민감한 데이터가 있는 경우 적절한 접근 제어가 필요합니다.

Lombok을 사용하려면 프로젝트에 Lombok 라이브러리를 추가해야 하며, IDE(예: IntelliJ, Eclipse) 설정에서 Lombok 플러그인을 활성화해야 합니다.


4. DTO 와 MAP으로 앞단(Controller)에 보내기
> `DTO`를 만들어서 컨트롤러에 보내는 방식과 `Map`에 담아서 보내는 방식 각각의 장단점이 있으며, 일반적으로 **DTO를 사용하는 것이 더 권장되는 방법**입니다. 이유는 아래와 같습니다:

 DTO 사용 방식

DTO(Data Transfer Object)는 특정한 데이터 구조를 정의한 객체로, 클라이언트와 서버 간 데이터 교환 시 명확한 데이터 구조를 제공하고 데이터를 캡슐화하는 데 유리합니다.

장점
- 명확한 데이터 구조: DTO는 명확한 필드와 구조를 가지므로, 어떤 데이터가 포함되어 있는지 쉽게 파악할 수 있습니다. 이로 인해 코드 가독성과 유지보수가 쉬워집니다.
- 타입 안정성*: DTO는 특정 타입을 명시하기 때문에, 잘못된 데이터나 타입 에러가 줄어들고, 컴파일 시점에 오류를 검출할 수 있습니다.
- 유지보수 용이성: 데이터가 바뀔 때 DTO를 수정하면 되므로 유지보수가 용이합니다. 데이터 구조가 변경되면 DTO 클래스만 수정하면 되므로 전체 코드에서의 영향을 최소화할 수 있습니다.
- 데이터 보호: DTO는 필요한 필드만 포함할 수 있어 민감한 정보를 보호하는 데 유리합니다. 불필요한 데이터 노출을 줄이고, 전송해야 하는 데이터의 양을 조절할 수 있습니다.

 단점
- 클래스 파일이 늘어남: DTO를 매번 생성해야 하므로, 클래스 파일이 많아질 수 있습니다.



 2. Map 사용 방식

`Map`은 **키-값 구조**로 데이터를 저장하며, DTO 객체를 사용하지 않고도 데이터 그룹을 유연하게 담아 전송할 수 있습니다.

장점
- 유연성: DTO를 만들지 않아도 다양한 데이터를 즉시 담아 보낼 수 있습니다.
- 간단한 데이터 구조: 임시적인 데이터 구조가 필요할 때, 간단한 응답 데이터에는 적합할 수 있습니다.

단점
- 타입 안정성이 없음: `Map`의 값은 특정 타입으로 제한되지 않으므로, 타입 오류가 발생할 수 있습니다. 잘못된 데이터를 참조할 가능성이 있습니다.
- 코드 가독성 저하: `Map`의 키 값들이 명확하지 않으면 코드 가독성이 떨어질 수 있으며, 특히 키 이름을 오타 내면 런타임 오류가 발생할 수 있습니다.
- 유지보수 어려움: 데이터 구조가 바뀔 때마다 키와 값을 수동으로 수정해야 하며, 데이터 구조의 변경 사항이 코드 전반에 영향을 미칠 수 있습니다.


#### 어떤 방식이 더 나은가?
일반적으로 **DTO 사용이 더 나은 방식**입니다. 이유는 다음과 같습니다:

1. **코드의 명확성과 안전성**: DTO는 데이터 구조를 명확하게 정의하여 가독성을 높이고, 타입 안정성을 제공하므로 코드의 안전성을 높입니다.
2. **유지보수 용이**: 데이터 구조가 바뀔 때 DTO만 수정하면 되므로, 코드를 유지보수하는 데 유리합니다.
3. **의미 있는 데이터 전송**: DTO를 사용하면 데이터를 더 잘 보호하고, 의미 있는 필드들만 노출할 수 있습니다. 데이터 보호와 성능 측면에서 유리합니다.

### 결론

- **데이터가 구조화되어 있고 명확한 의미가 있는 경우**에는 DTO를 사용하는 것이 좋습니다.
- 단, **매우 간단한 응답이나 임시적인 데이터 전송이 필요한 경우**에는 Map을 사용할 수도 있습니다.