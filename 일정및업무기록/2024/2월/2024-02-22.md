

항공권 예약 시, 항공사에서 준 PNR(숫자+알파벳)이라는 정보를 받는데 GDS에 따라 항공사PNR 외에 8자리 숫자로 된 PNR예약번호가 들어오는 경우가 존재한다. 실제 운영팀에서는 항공사PNR을 기준으로 데이터를 보는 경우가 많은데, 백오피스에선 두 PNR 정보가 분리되지 않고 PNR1, PNR2로 순서가 뒤섞여서 적재가 되고 있었다.  
요런 배경에서 정산 시스템에선 해당 PNR을 분리하려고 했는데 아무 생각 없이 `Double.parse()`로 숫자인지 판단하도록 했다. 근데 웬걸... 항공사PNR이 숫자로 인식되어서 잘못 들어가 있네... 해서 이 김에 문자열이 숫자인지 검증하는 방법을 정리해봤다.

### `Double.parseDouble()` 메소드 try-catch

```java
    public boolean isNumberic(String str) {
    	try {
    	  Double.parseDouble(str);
      } catch (NumberFormatException e) {
    	  return false;
      }
      return true;
    }
```

_하지만, D나 E 문자가 들어갈 경우 Double로 형변환이 되어 버그 발생할 수 있음_

### `String.matches()` 메서드 활용

정규식을 활용해 숫자형식인지 활용

```java
    public static boolean isNumberic(String str) {
        return str.matches("[+-]?\\d*(\\.\\d+)?");
      }
```

### Character 클래스의 `.isDigit()` 메서드 활용

- Java 8 미만  
    

```java
    public boolean isNumberic(String str) {
    	boolean result = true;
    	for(char c : str.toCharArray()){
    		if(!Character.isDigit(c) {
    			result = false;
    			break;
    		}
    	}
    	return result;
    }
```

- Java 8 이상  







```java
    public static boolean isNumberic(String str) {
        return str.chars().allMatch(Character::isDigit);
      }
```


```java
public class SimpleTesting {
  public static void main(String[] args) {
    String str = "123";
    boolean isNumeric = str.matches("[+-]?\\d*(\\.\\d+)?");
    System.out.println(isNumeric);
    str = "121xy";
    isNumeric = str.matches("[+-]?\\d*(\\.\\d+)?");
    System.out.println(isNumeric);
    str = "0x234";
    isNumeric = str.matches("[+-]?\\d*(\\.\\d+)?");
    System.out.println(isNumeric);
  }
}
```