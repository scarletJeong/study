`2024-12-09`

- [ ] Map에 담겨있는 것을 오름/내림 차순으로 정렬하기
- [ ] 익명클래스
- [ ] 람다식
- [ ] entrySet( )
- [ ] map.getOrDefault(i, 0) +1 )


#### 익명클래스 
>	- 간결성
>		- 인터페이스(추상 클래스)의 메서드를 즉석에서 구현하여, 코드 내에서 필요에 따라 바로 사용할 수 있어서.
>	- 일회성 동작
>		- 별도의 클래스를 정의하지 않고 특정 동작을 정의하고 사용할 수 있음.
>	- 캡슐화
>		- 특정 동작으로 코드내에서 로컬로 캡슐화할 수 있음.
>		
>	
>	- 언제 익명 클래스를 사용해야 함?
>		- 한 번만 사용하는 경우
>			- 특정 맵을 정렬할때 사용하는 Comparator
>		- 간단한 동작일 경우
>			- ex) 정렬기준 정의, 이벤트 핸들러 정의


#### 람다식과 익명클래스의 관계
>	- **JAVA에서 인터페이스나 추상클래스의 메서드를 구현할 때 사용**
>	
>	- 왜 람다식을 쓰지 않으면 익명클래스가 필요함?
>		- 1. 인터페이스나 추상클래스의 구현은 필수
>			- 익명클래스는 구현을 제공하기 위한 도구
>		- 2. 람다식은 익명클래스의 간결한 표현 문법

```
- 익명클래스로 Comparator 구현
TreeMap<Integer, Integer> map = new TreeMap<>(new Comparator<Integer>(){
	
	public int compare(Integer o1, Integer o2){
		return o1.compareTo(o2);
	}
});

- 람다식으로 Comparator 구현
TreeMap<Integer, Integer> map = new TreeMap<>((o1,o2) -> o1.compareTo(o2));
```

>			- 3. 람다식은 단일 메서드 인터페이스만 사용가능
>				- **단일 메서드 인터페이스**만 구현 할 수 있음.
>				- 익명클래스는 다중 메서드 구현이나 특정 클래스 확장에도 사용됨.



#### 람다식
`-` 단일 메서드 인터페이스(Functional Interface)를 간결하게 구현하기위한 문법

>	1. 문법
>		(매개변수) -> { 함수의 동작 }
>
>		매개변수 목록
>		화살표 (->)  : '매개변수'와 '함수의동작'을 구분
>		함수의 동작 : 수행할 작업 정의 
>		
>	2. 사용 조건
>		1. 단일 메서드 인터페이스 (Functional Interface)
>			- 메서드가 하나만 정의된 인터페이스 구현 시
>			- ex) Comparator, Runnable, Callable, Consumer 등
>		2. 구현할 메서드가 명확할 때
>			- 익명 클래스를 간단하게 표현 할 수 있는 경우.
>	

```
1. Runnable
before
	Runnable task = new Runnable(){
		public void run(){
			System.out.println("Hello");
		}
	}
	
after
	Runnable task = () -> System.out.println("Hello");

2.Consumer
before
	List<String> fruits = Arryas.asList("Apple", "Bannan", "Cheery");
	
	Consumer<String> printConsumer = new Consumer<String>(){
		public void accept(String fruit){
			System.out.println(fruit);
		}
	};
	
	fruits.forEach(printConsumer);

after
	List<String> fruits = Arryas.asList("Apple", "Bannan", "Cheery");
	
	Comsumer<String> printConsumer = (fruit) -> System.out.println(fruit);
	
	fruits.forEach(printConsumer);
```

>		3. 람다식 활용 예제
>			- StreamAPI 사용
>			- Tread 생성
>			- Map 정렬



#### getOrDefault( )
`-` 맵에 특정 키가 존재하면 해당키의 값을 반환하고, 그렇지않으면 기본값을 반환함
`-` null을 반환하지 않으므로, NullPointerException 방지

>	V getOrDefault ( Object key, V defaultValue )
>	- key : 검색할 키
>	- dafaultValue : 키가 존재하지 않을 때 반환할 기본값.
>
> 	 **map.put ( i, map.getOrDefault ( i, 0)  +1 )**
> 	 - map.getOrDefault ( i, 0 )
> 		 - i 라는 키가 맵에 존재하면 해당 키의 값을 반환
> 		 - i 라는 키가 맵에 없으면 기본값 0 반환
> 		 - 이 코드는 맵에서 키 i의 현재값을 가져오거나, 없으면 0을 가져오는 역할
> 	- +1
> 		- 키 i의 값을 증가
> 		- 여기서는 키 i가 이미 존재하면 기존 값에 1을 더함. 존재하지 않으면 0에서 1로 증가
> 	- map.put(i, ...)
> 		- 계산된 값을 맵에 다시 젖.ㅇ
> 		- 즉, 키 i의 값을 map에 업데이트하거나 새로 삽입

```
기존 (get + 조건문)

if( map.containskey(i)){
	map.put(i, map.get(i) + 1 );
}else{
	map.put(i, 1);
}
```





```
import java.util.*;
class Solution {
	public int solution(int k, int[] tangerine) {
		int answer = 0;        
		Comparator<Integer> c = (s1,s2)->s1.compareTo(s2);
		
		//Key: 크기  , value: 갯수
		Map<Integer,Integer> map = new HashMap<>();
				
		for(int i=0;i<tangerine.length;i++){
			int count = map.getOrDefault(tangerine[i],0);
			map.put(tangerine[i],count+1);
		}
				
		List<Integer> valueList = new ArrayList(map.values());
		Collections.sort(valueList,Collections.reverseOrder());
				
		for(int i=0;i<valueList.size();i++){
			k-=valueList.get(i);
			answer++;
			if(k<=0){
				break;
			}
		}
				
		return answer;
	}
}


1. `map.values()`
- `map.values()`는 `Map`에 저장된 모든 값(value)을 반환
- 반환 타입은 `Collection<V>`이며, 이 값들을 리스트로 변환하여 정렬이 가능

2. `new ArrayList<>(map.values())`
- `map.values()`로 반환된 값을 `ArrayList`에 담음
- 이렇게 함으로써, 값들을 수정하거나 정렬할 수 있는 리스트를 생성

3. `Collections.sort(valueList, Collections.reverseOrder())`
- `Collections.sort()`는 리스트를 정렬(오름차순)하는 정적 메서드
- `Collections.reverseOrder()`는 역순인 내림차순으로 정렬


- 값(value) 들만 추출하여 리스트로 변환.
- 리스트를 내림차순으로 정렬.
- 키-값 쌍을 유지하지 않고, 값 자체만 정렬할 때 사용.
```