# List와 배열 그리고 Set

## 소개

문제풀다가 Set에 넣은 배열사이즈가 1개밖에 잡히는것을 보고, 배열과 리스트가 다름을 알고 학습하게 되었음. 
그래서 int[](배열)과 list<Integer>의 차이점, 그리고 Set에 대한 차이점을 공부하겠음.

---
주요 내용
---

### 1. `Set<int[]>`에 데이터가 하나만 들어가는 이유
1. **배열 참조 문제**:
   - `int[]`는 **객체의 참조(주소)**를 기준으로 `HashSet`에서 중복 여부를 판단.
   - 동일한 배열 객체(`move`)를 수정하여 사용하는 경우, `HashSet`은 참조 주소가 동일하다고 판단해 중복으로 간주.

2. **HashSet의 중복 판단 기준**:
   - **`hashCode`와 `equals`** 메서드를 기반으로 중복 여부를 판단.
   - 배열(`int[]`)은 기본적으로 `Object`의 `hashCode`와 `equals`를 상속받아 **참조 주소**를 기준으로 비교.
   - 배열의 내용이 변경되더라도 참조 주소가 동일하면 중복으로 간주.

---

### 2. int[]과 List의 중복 판단 기준

#### int[]의 중복 판단
- `int[]`는 참조 주소를 기준으로 중복을 판단하기 때문에, 내용이 같아도 다른 객체면 중복으로 간주되지 않음.

#### List의 중복 판단
- `List`는 중복 여부를 판단하지 않고, 순서대로 값을 저장.
- 동일한 내용의 배열이라도 다른 배열 객체라면 모두 저장.

#### Set과 List의 차이 요약
| **특징**            | **int[]**                    | **List<>**                 |
|---------------------|-----------------------------------|---------------------------------|
| **중복 여부 판단**   | 참조 주소를 기준으로 중복 판단        | 중복을 허용하며 값 순서대로 저장    |
| **용도**            | 고유한 객체 참조 관리                | 순서에 따라 데이터 저장            |


---

### 3. List와 메서드 반환 타입 문제

#### `List.add()`의 반환 타입
- **`add(E element)`의 반환 타입**:
  - `boolean` 타입을 반환하며, 추가 작업 성공 여부를 나타냄.
  - 반환값은 `true` 또는 `false`.

#### 문제: `List<Integer> list = list.add(...);`
- **원인**:
  - `list.add(...)`는 리스트에 요소를 추가하지만, 기존 리스트를 반환하지 않음.
  - 반환값은 `boolean`이므로, `list`에 다시 할당하려는 시도는 타입 불일치로 컴파일 에러가 발생.

#### 올바른 수정 방법
- 리스트에 값을 추가한 후 별도의 작업을 수행해야 함:
  ```java
  list.add(list.get(1) + 1);
  ```

---

### 4. 문제풀이

#### 1) 경로 처리 문제
- `(0,0) → (0,1)`과 `(1,1) → (0,1)`은 다른 경로로 판별해야 함.
- 해결 방법:
  - 항상 **작은 좌표를 먼저 저장**하여 양방향을 동일하게 처리.
  - 예제 코드:
    ```java
    String path = Math.min(x1, x2) + "," + Math.min(y1, y2) + "->" +
                  Math.max(x1, x2) + "," + Math.max(y1, y2);
    ```

#### 2) 중복문제  > `newlist.containsAll(list)` 문제
- **원인**:
  - `containsAll`은 **순서나 맥락을 고려하지 않고**, 동일한 요소가 모두 포함되어 있는지만 확인.


#### 3) Map과 좌표 이동 처리

#### Map을 사용한 방향 이동 계산
- **코드**:
  ```java
  Map<Character, int[]> directions = new HashMap<>();
  directions.put('U', new int[]{0, 1});
  directions.put('D', new int[]{0, -1});
  directions.put('R', new int[]{1, 0});
  directions.put('L', new int[]{-1, 0});

  for (char dir : dirs.toCharArray()) {
      int nx = x + directions.get(dir)[0];
      int ny = y + directions.get(dir)[1];
  }
  ```

#### 동작 원리
1. **`dirs.toCharArray()`**:
   - 문자열을 문자 배열로 변환.
   - 예: `"ULDR"` → `['U', 'L', 'D', 'R']`.

2. **`directions.get(dir)`**:
   - `dir`(문자)에 해당하는 방향 벡터를 가져옴.
   - 예: `directions.get('U')` → `[0, 1]`.

3. **좌표 계산**:
   - 현재 좌표 `(x, y)`에 방향 벡터를 더해 새로운 좌표 `(nx, ny)` 계산.
   - 예: `nx = x + 0`, `ny = y + 1` (위로 이동).

---

## 깨달은 점

1. **`Set<int[]>`의 동작 원리 이해**:
   - 참조 주소를 기준으로 중복을 판단하는 특성을 학습함.

2. **`List`와 `Set`의 차이점**:
   - 각 자료구조의 중복 처리 기준과 활용 방법을 명확히 이해함.

3. **좌표 이동 처리의 효율성**:
   - `Map`과 방향 벡터를 활용하면 좋겠지만 사실 이해가 제대로 되지 않았음.


