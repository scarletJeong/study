- [ ] garbage collector 
- [ ] 멀티태스킹
- [ ] 프로세스와 스레드 
- [ ] 여행-대만
- [ ] 블로그


## Garbagage Collector

#### 가비지(Garbagage) : 유효하지 않은 메모리
`자바, kotlin은 개발자가 메모리를 직접 '해제'해주는 일이 없음. 왜냐면 JVM의 가비지 컬렉터가 불필요한 메모리를 주기적으로 자동 정리해줘서임. 
` 
`so, 메모리 누수 (memory Leak)문제에대해 관리하지 않고 오롯이 개발에만 집중가능
`C/C++언어는 수동으로 메모리 할당과 해제 해줘야함. 

+단점 
- 메모리가 언제 해제되는지 시점을 정확히 알 수 없음. 
- GC가 동작하는 동안에 다른 동작도 멈춤 = 오버헤드 발생. 

----
#### JVM의 'Heap영역'의 설계 전제
` Heap영역은 동적으로 참조 데이터가 저장되는 공간 = 가비지 컬렉션 대상이 되는 공간. 

- 대부분의 객체는 금방 접근 불가능한 상태(unreachable)이 됨. 
` Reachable : 객체가 참고되고 있는 상태
 `UnReachable : 객체가 참조되지 않은 상태 = GC의 대상
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재함. 
- 
 $\rightarrow$  객체는 대부분 일회성이면, 메모리에 오랫동안 남아있는 경우는 드물다. 
 $\rightarrow$   생존 기간에 따라 물리적으로 heap의 영역을 나눔.(Young / Old)


- ##### Young Generation
	-새롭게 생성된 객체가 할당되는 영역
	-많은 객체가 이 영역에 생성되었다가 사라짐.
	-young 영역에 대한 가비지 컬렉션(GC)을 Minor GC라고 함.
	
- ##### Old Generation
-Young영역에서 Reachable상태를 유지하여 살아남은 객체가 복사되는 영역
-Young영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생함.
-Old영역에 대한 GC를 Majoir GC라고 함.

	old 영역이 young보다 크게 할당되는 이유
	young영역은 수명이 짧아 큰 공간을 필요로 하지 않음. 
	큰 객체들은 바로 Old영역으로 할당됨



``` 
JVM 메모리에서는 객체들은 실질적으로 Heap영역에서 생성되고 Method, Stack 영역에서는 Heap영역에 생성된 객체의 주소만 참조하는 형식으로 구성됨.

하지만 Heap영역의 객체안에 참조변수가 삭제되는 현상이 발생하면, heap영역에서는 어디서든 참조하고 있지 않은 객체(Unreachable)들이 발생함. 

이런 객체들을 주기적으로 가바지 컬렉터가 제거해주는 거임. 
``` 

---

#### Garbage Collection의 동작방식(순서대로)
1. Stop the World
2. Mark and Sweep


1. Stop the World
: JVM이 애플리케이션의 실행을 멈추는 작업
- GC가 실행될 때는 GC를 실행하는 쓰레드를 제외한 '모든' 쓰레드들의 작업이 '중단'되고, GC가 완료되면 작업이 재개됨.
- 실시간이 강조되는 프로그램일 경우 GC에 메모리를 맞기는 것은 맞지 않을 수 있음.
`모든 쓰레드들의 작업이 중단되면 애플리케이션이 멈추기 때문에, GC의 성능개선을 위해 튜닝 = stop the world의 시간을 줄이는 것.

` explore(익스플로러)가 GC를 너무 자주 실행하여 성능문제를 일으키는 것으로 악명 놓음. 

2. Mark and Sweep
- Mark : 사용되는 메모리와 사용되지 않는 메모리를 '식별'하는 작업
- Sweep : Mark 단계에서 '사용되지 않음'으로 식별된 '메모리를 해제'(Heap영역에서 제거)하는 작업. 

`1번_Stop the world를 통해 모든 작업을 중단시키면, GC는 스택의 모든 변수 또는 Reachable객체를 스캔하면서 각각이 어떤 객체를 참고하고 있는지를 탐색. 

`그리고 '사용되고 있는' 메모리를 식별하는 과정을 Mark라고하고, 이후 Mark가 되지 않은 객체들을 메모리에서 제거하는 과정을 Sweep라고 함.

---

#### Minor GC 
: Young영역에 메모리 정리
###### 1. Young 영역 구조 이해
 Young 영역(3) = Eden + Survivor * 2 (Survivor_0 ,Survivor_1 )
 - Eden : 새로 생성된 객체가 할당되는 영역
 - Survivor : 최소 1번의 GC 로부터 살아남은 객체가 존재하는 영역

`객체가 새롭게 생성되면 Young영역 중 - 'Eden'영역에 할당됨. 

Eden 영역이 꽉 차면 Minor GC가 발생.
사용되지 않는 메모리는 해제되고, 사용 중인 (Eden영역에 존재하는 객체)객체는 Survivor영역으로 옮겨짐. 

!! Survivor의 영역은 총 2개 이지만, 반드시 1개의 영역에만 데이터가 존재해야함 !!
 -> why?

###### 2. Young 동작 순서
(1) 새로 생성된 객체가 Eden에 할당
(2) 객체가 계속 생성되어 Eden 영역이 꽉 참 $\rightarrow$  Minor GC 발생
	(2)-1 . Eden 영역에서 사용되지 않은 객체 메모리 해제.
	(2)-2. Eden 영역에서 살아남은 객체는 1개의 Survivor영역(1번 Survivor영역) 으로 이동
(3) 1~2번의 과정이 반복되다가 1번 Survivor영역이 가득차게 되면 1번Survivor영역의 살아남은 객체를 다른 Survivor영역(2번Survivor영역) 으로 이동시킴.  = 1번 Survivor영역은 '반드시' 빈 상태가 됨.
(4) 위 과정을 반복해서 살아남은 객체는 Old영역으로 이동(Promotion)됨. 




![](https://blog.kakaocdn.net/dn/Cyho2/btqURvZRql6/4a7u6mMGofkpuURKQz0RT1/img.png)

Survivor영역 중 1개는 반드시 사용되어 있어야함. 
` 만약 두 Survivor영역에 모두 데이터가 존재하거나, 모두 사용량이 0이면 비정상 상황임.



+age
 : 객체의 횟수 카운트 =  객체가 살아남은 횟수 
 - Object Header 에 기록. 
 - Minor GC 때 Object Header에 기록된 age를 보고 이동(promotion)을 결정함. 

+
HopSpot JVM에서는  Eden영역에 객체를 빠르게 할당하기위해 (1)Bump the pointer 와 (2)TLABs(Thread-Local Allocation Buffers)라는 기술을 사용함. 

1. Bump the pointer 
: Eden 영역에 마지막으로 할당된 객체의 주소를 캐싱해두는 것.
- 새로운 객체를 위해 유효한 메모리를 탐색할 필요없이 마지막주소의 다음주소를 사용하게 함으로써 속도를 높임. 
- so, 새로운 객체를 할당할 때 '객체의 크기'가 Eden영역에 '적합'한지만 판별하면 됨. 
- 빠른 메모리 할당 가능
- 싱글 쓰레드 환경에 유용


But, '멀티'쓰레드 환경이면 객체를 Eden영역에 할당할때 락(Lock)을 걸어 '동기화'해줘야함.
2. TLABs(Thread-Local Allocation Buffers) 
-  각각의 쓰레드마다 Eden 영역에 객체를 할당하기 위한 '주소를 부여'
- '동기화작업없이' 빠르게 메모리를 할당하도록 하는 기술.


#### Major GC의 동작 방식
: Old영역의 메모리가 부족해지면 발생

(1) 객체의 age가 임계값에 도달
(2) Old Generation으로 이동 = 이를 'Promotion'이라 함. 
(3) 위 과정이 반복되여  Old영역의 공간(메모리)가 부족하면 Major GC 발생

- Old영역에 있는 모든 객체들을 검사하여 참조되지 않는 객체들을 한꺼번에 삭제함.
- 상대적으로 큰 공간을 가지고 있어, 객제 정리(제거)에 많은 시간 소요됨.
$\rightarrow$ STW(Stop - the -World) 문제 발생. 
 +heap의 사이즈가 커지면서 애플리케이션의 지연(suspend)현상이 두드러짐

$\rightarrow$  가비지 컬렉션 알고리즘 지원
` GC 알고리즘은 모두 설정을 통해 JAVA에 적용할 수 있음.


----

1. Serial GC 
- 가장 단순
- 서버의 CPU코어가 1개일 때 사용
- Minor GC : Mark-Sweep / Major GC : Mark-Sweep-Compact 사용

2. Parallel GC
- 기본적인 알고리즘은 같지만, Young영역의 Minor GC를 '멀티 쓰레드'로 수행. 
- Old영역은 여전히 싱글 쓰레드
- so, Serial GC에 비해 STW 시간 감소

3. Parallel Old GC (Parallel Compacting Collector)
- Parallel GC를 개선한 버전
- Young 영역뿐만 아니라, Old 영역에서도 멀티쓰레드로  GC 수행
- 새로운 가비지 컬렉션 청소방식인 Mark-Summary-Compact 방식 이용. 

4. CMS GC (Concurrent Mark Sweep)
- 어플리케이션의 쓰레드와 GC쓰레드가 동시에 실행되어 STW시간을 최대한 줄이기 위해 고안된 GC/
- 단, GC과정이 매우 복잡해짐.
- GC 대상을 파악하는 과정이 복잡한 여러 과정으로 수행
--> 다른 GC대비 CPU사용량이 높음
- 메모리 파편화 문제 


5. G1 GC(Garbage First)
- CMS GC를 대체하기 위해 jdk7버전에서 최초로 출시
- 기존의 GC알고리즘에서는 Heap영역을 물리적으로 고정된 Young/Old 영역으로 나누어 사용하였지만, G1 GC는 아예 이런 개념을 뒤엎어 사용. 
- 전체 Heap 영역을 Region이라는 영역으로 체스같이 분할하여 상황에 따라 Eden, Survivor, Old등 역할을 고정이 아닌 '동적'으로 부여

``` 
이전 GC에서는 일일히 메모리를 탐색해 객체들을 제거했음. 
G1부터는 메모리가 많이 차있는 영역(Region)을 인식하는 기능을 통해 메모리가 많이 차있는 영역을 우선적으로 GC함. 

즉, G1 GC는 Heap Memory 전체를 탐색하는 것이 아닌 영역(Region)을 나눠탐색후, 영역별로 GC 발생. 

순차적으로 이동하지 않음. 
대신 G1 GC는 더욱 효율적이라고 생각하는 위치로 객체를 '재할당'(ReAllocate)함. 
```


6. Shenandoah GC
- 기존 CMS가 가진 단편화, G1이 가진 pause이슈 해결
- heap사이즈에 영향을 받지않고 일정한 pause시간 소요함. 

7. ZGC (Z Garbage Collector)
- 대량의 메모리를 low-latency로 잘 처리하기 위해 디자인된 GC
- G1의 Region처럼,  ZGC는 ZPage라는 영역을 사용
- heap크기가 증가하더라도 STW의 시간이 절대 10ms를 넘지 않음. 