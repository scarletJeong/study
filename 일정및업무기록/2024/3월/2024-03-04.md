ORA-01839_윤년_INTERVAL to ADD_MONTHS 해결책 공지  
  
  
문제 원인 및 해결책  
interval 함수 윤달 계산 시 에러, add_months로 대체  
==> INTERVAL + MONTH/YEAR ==> ADD_MONTHS() 함수로 변경 권장.  
  
## INTERVAL + MONTH/YEAR 2월 윤달 문제점  
SELECT TO_DATE('2024-02-29', 'YYYY-MM-DD') - INTERVAL '1' YEAR  
FROM DUAL;  
--ORA-01839: 지정된 월에 대한 날짜가 부적합합니다  
  
SELECT ADD_MONTHS(TO_DATE('2024-02-29', 'YYYY-MM-DD'), -12*5)  
FROM DUAL;  
--2019/02/28 00:00:00  
  
SELECT TO_DATE('2024-02-28', 'YYYY-MM-DD') - INTERVAL '5' YEAR  
FROM DUAL;  
--2019/02/28 00:00:00  
  
SELECT ADD_MONTHS(TO_DATE('2024-02-28', 'YYYY-MM-DD'), -12*5)  
FROM DUAL;  
--2019/02/28 00:00:00  
  
  
SELECT TO_DATE('2022-02-29', 'YYYY-MM-DD') + INTERVAL '1' MONTH  
FROM DUAL; -- ORA-01839  
SELECT TO_DATE('2023-03-31', 'YYYY-MM-DD') - INTERVAL '1' MONTH  
FROM DUAL; -- ORA-01839  
SELECT TO_DATE('2024-03-31', 'YYYY-MM-DD') - INTERVAL '1' MONTH  
FROM DUAL; -- ORA-01839  
SELECT TO_DATE('2024-02-29', 'YYYY-MM-DD') - INTERVAL '1' YEAR  
FROM DUAL; -- ORA-01839  
SELECT ADD_MONTHS(TO_DATE('2023-03-31', 'YYYY-MM-DD'), -1)  
FROM DUAL; -- 2023-02-28  
SELECT ADD_MONTHS(TO_DATE('2024-02-29', 'YYYY-MM-DD'), -12)  
FROM DUAL; -- 2023-02-28  
  
  
  
문제가 발생한 부분 예시  
  
, NVL((SELECT 'Y' -- 원무동의서  
FROM pam.pmchpecm pecm  
WHERE pecm.instcd = inpt.instcd  
AND pecm.pid = inpt.pid  
AND pecm.consentflag = '26'  
AND pecm.histstat = 'Y'  
AND pecm.rgstdd >= TO_CHAR(SYSDATE - (interval '5' year), 'YYYYMMDD')  
AND ROWNUM = 1  
), (SELECT 'Y' -- OCR  
FROM emr.mrfmocrprnt prnt  
, emr.mrfhocrprnt hprnt  
WHERE prnt.instcd = inpt.instcd  
AND prnt.pid = inpt.pid  
AND prnt.formcd IN (SELECT code.supcdid  
FROM emr.mnwmcode code  
WHERE code.instcd = '013'  
AND code.cdgrupid = '941'  
AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN code.valifromdd AND code.valitodd  
)  
AND prnt.instcd = hprnt.instcd  
AND prnt.ocrtag = hprnt.ocrtag  
AND hprnt.statcd NOT IN ('P', 'D', 'CP') -- STATCD 상태코드 (출력:P, 반납:R, 반납확인:C, 삭제:D, 출력취소:CP, 반납취소:CR, 반납확인취소:CC, 삭제취소:CD)  
AND hprnt.lastupdtdt = (  
SELECT max(x.lastupdtdt)  
FROM emr.mrfhocrprnt x  
WHERE x.instcd = hprnt.instcd  
AND x.ocrtag = hprnt.ocrtag  
)  
AND SUBSTR(prnt.fstprntdt,1,8) >= TO_CHAR(SYSDATE - (interval '5' year), 'YYYYMMDD')  
AND ROWNUM = 1)  
) AS pecmnursyn -- 간호사 교대제 개선 시범사업 관련 동의서 취득여부  
  
  
  
수정 후  
  
, NVL((SELECT 'Y' -- 원무동의서  
FROM pam.pmchpecm pecm  
WHERE pecm.instcd = inpt.instcd  
AND pecm.pid = inpt.pid  
AND pecm.consentflag = '26'  
AND pecm.histstat = 'Y'  
AND pecm.rgstdd >= TO_CHAR(ADD_MONTHS(SYSDATE, -12*5), 'YYYYMMDD')  
AND ROWNUM = 1  
), (SELECT 'Y' -- OCR  
FROM emr.mrfmocrprnt prnt  
, emr.mrfhocrprnt hprnt  
WHERE prnt.instcd = inpt.instcd  
AND prnt.pid = inpt.pid  
AND prnt.formcd IN (SELECT code.supcdid  
FROM emr.mnwmcode code  
WHERE code.instcd = '013'  
AND code.cdgrupid = '941'  
AND TO_CHAR(SYSDATE, 'YYYYMMDD') BETWEEN code.valifromdd AND code.valitodd  
)  
AND prnt.instcd = hprnt.instcd  
AND prnt.ocrtag = hprnt.ocrtag  
AND hprnt.statcd NOT IN ('P', 'D', 'CP') -- STATCD 상태코드 (출력:P, 반납:R, 반납확인:C, 삭제:D, 출력취소:CP, 반납취소:CR, 반납확인취소:CC, 삭제취소:CD)  
AND hprnt.lastupdtdt = (  
SELECT max(x.lastupdtdt)  
FROM emr.mrfhocrprnt x  
WHERE x.instcd = hprnt.instcd  
AND x.ocrtag = hprnt.ocrtag  
)  
AND SUBSTR(prnt.fstprntdt,1,8) >= TO_CHAR(ADD_MONTHS(SYSDATE, -12*5), 'YYYYMMDD')  
AND ROWNUM = 1)  
) AS pecmnursyn -- 간호사 교대제 개선 시범사업 관련 동의서 취득여부  
  
  
구글검색어  
ora-01839  
oracle interval leap year  
  
  
[https://forums.oracle.com/ords/apexds/post/query-containing-sysdate-interval-1-year-fails-for-today-s-8596](https://forums.oracle.com/ords/apexds/post/query-containing-sysdate-interval-1-year-fails-for-today-s-8596)  
[https://asktom.oracle.com/ords/f?p=100:11:::NO::P11_QUESTION_ID:9522259800346897152](https://asktom.oracle.com/ords/f?p=100:11:::NO::P11_QUESTION_ID:9522259800346897152)  
[https://forums.oracle.com/ords/apexds/post/bug-abount-interval-by-year-10-in-case-of-leap-year-it-fail-9373](https://forums.oracle.com/ords/apexds/post/bug-abount-interval-by-year-10-in-case-of-leap-year-it-fail-9373)  
[https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-E405BBC7-DA9A-4DF2-9F22-E60CB9EC0705](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-E405BBC7-DA9A-4DF2-9F22-E60CB9EC0705)  
  
  
Datetime/Interval Arithmetic  
You can perform a number of arithmetic operations on date (DATE), timestamp (TIMESTAMP, TIMESTAMP WITH TIME ZONE, and TIMESTAMP WITH LOCAL TIME ZONE) and interval (INTERVAL DAY TO SECOND and INTERVAL YEAR TO MONTH) data. Oracle calculates the results based on the following rules: You can use NUMBER constants in arithmetic operations on date and timestamp values, but not interval values. Oracle internally converts timestamp values to date values and interprets NUMBER constants in arithmetic datetime and interval expressions as numbers of days. For example, SYSDATE + 1 is tomorrow. SYSDATE - 7 is one week ago. SYSDATE + (10/1440) is ten minutes from now. Subtracting the hire_date column of the sample table employees from SYSDATE returns the number of days since each employee was hired. You cannot multiply or divide date or timestamp values. Oracle implicitly converts BINARY_FLOAT and BINARY_DOUBLE operands to NUMBER. Each DATE value contains a time component, and the result of many date operations include a fraction. This fraction means a portion of one day. For example, 1.5 days is 36 hours. These fractions are also returned by Oracle built-in functions for common operations on DATE data. For example, the MONTHS_BETWEEN function returns the number of months between two dates. The fractional portion of the result represents that portion of a 31-day month. If one operand is a DATE value or a numeric value, neither of which contains time zone or fractional seconds components, then: Oracle implicitly converts the other operand to DATE data. The exception is multiplication of a numeric value times an interval, which returns an interval. If the other operand has a time zone value, then Oracle uses the session time zone in the returned value. If the other operand has a fractional seconds value, then the fractional seconds value is lost. When you pass a timestamp, interval, or numeric value to a built-in function that was designed only for the DATE data type, Oracle implicitly converts the non-DATE value to a DATE value. Refer to [Datetime Functions](https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Single-Row-Functions.html#GUID-5652DBC2-41C7-4F07-BEDD-DAF620E35F3C) for information on which functions cause implicit conversion to DATE. When interval calculations return a datetime value, the result must be an actual datetime value or the database returns an error. For example, the next two statements return errors:  
  
Copy  
SELECT TO_DATE('31-AUG-2004','DD-MON-YYYY') + TO_YMINTERVAL('0-1')  
FROM DUAL;  
  
SELECT TO_DATE('29-FEB-2004','DD-MON-YYYY') + TO_YMINTERVAL('1-0')  
FROM DUAL;  
  
The first fails because adding one month to a 31-day month would result in September 31, which is not a valid date. The second fails because adding one year to a date that exists only every four years is not valid. However, the next statement succeeds, because adding four years to a February 29 date is valid:  
  
Copy  
SELECT TO_DATE('29-FEB-2004', 'DD-MON-YYYY') + TO_YMINTERVAL('4-0')  
FROM DUAL;  
  
TO_DATE('  
---------  
29-FEB-08  
  
Oracle performs all timestamp arithmetic in UTC time. For TIMESTAMP WITH LOCAL TIME ZONE, Oracle converts the datetime value from the database time zone to UTC and converts back to the database time zone after performing the arithmetic. For TIMESTAMP WITH TIME ZONE, the datetime value is always in UTC, so no conversion is necessary.  
  
출처: <https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html#GUID-E405BBC7-DA9A-4DF2-9F22-E60CB9EC0705>