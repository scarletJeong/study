
>	#스택(Stack)
>	- LIFO (Last In Frist Out) = 가장 나중에 추가된 데이터가 가장 먼저 제거
>	- 스택은 데이터의 **순서**가 중요하거나, 마지막에 추가한 데이터를 먼저 처리
>	  
>	- 기본 연산
>		- push : 데이터 추가
>		- pop  :  데이터 제거
>		- peek : 마지막 요소 확인
>		- isEmpty() : 스택이 비어있는 지 확인 (true / false)
>		- search(element) : 스택에서 해당요소의 위차 반환
>	
>	- 활용
>		- 재귀 처리 / 함수 호출 스택
>			- 컴퓨터는 함수 호출 시 스택을 이용해서 함수 호출 순서와 지역 변수 관리
>			- 함수가 다른 함수를 호출하면 현재의 함수의 실행상태를 스택에 저장하고, 새 함수를 실행 한 후 복귀(재귀)시 다시 꺼내어 실행 상태를 이어감
>			- ex ) 재귀함수, 트리 순회 등
>			  
>		- 웹 브라우저 앞/뒤로 가기
>			- 웹 브라우저에서 방문한 페이지를 스택에 쌓아두고, 페이지를 앞뒤로 이동
>			  
>		- 텍스트 에디터의 되돌리기/다시 실행(Undo / Redo)
>			- 작업을 스택에 저장하여 "Undo"를 통해 가장 마지막 작업을 되돌림
>			- "Redo"를 통해 되돌린 작업을 다시 적용가능
>			  
>		- 괄호 짝 맞추기와 같은 문자열 문제
>			- 스택을 이용해 괄호 짝 맞추기(ex : ({)}} ) 
>			- ex ) XML / HTML 태그의 열림-닫힘 짝 맞추기
>			  
>		- 수식 계산
>			- 컴퓨터는 수식 계산 시 스택을 활용하여 '후위 표기법'으로 변환하여 계산함.
>			- 중위표기법을 후위표기법으로 변환하거나 후위표기법을 평가하는데 스택이 많이 사용됨
>			  
>		- 깊이 우선 탐색(DFS)
>			- DFS알고리즘에서는 방문해야 할 노드를 스택에 쌓아두고, 가장 최근에 추가된 노드부터 탐색함.
>			- ex ) 미로 탐색, 그래프의 경로 찾기.
>			  
>	- 스택을 사용하는 이유
>		- 직관적 순서 유지
>			- `스택은 LIFO 특성으로 인해 가장 마지막에 실행한 작업을 되돌리거나 확인할 때 직관적`
>		- 추가 및 삭제 속도
>			- `데이터의 삽입/삭제가 상수시간(`O(1)`)에 이루어짐. 
>		- 단순 + 강력
>			- `구조가 단순하지만, 복잡한 알고리즘의 기초로 활용됨. 
>			- `특히 재귀, 되돌리기, 순서가 중요한 작업
>		- 메모리 관리
>			- `데이터를 순서대로 쌓아 관리 할 수 있어 메모리 사용량을 예측하고 관리하기 용이`


| 자료구조 | 접근방식   | EX                   | 차이점                                             |
| ---- | ------ | -------------------- | ----------------------------------------------- |
| 스택   | LIFO   | 재귀 호출, 되돌리기 기능, DFS  | 가장 마지막에 넣은 요소만 접근 가능                            |
| 큐    | FIFO   | 프린트 대기열, 작업 스케줄링     | 가장 먼저 넣은 요소가 가장 먼저 나옴, <br>순소대로 처리할 때 적합        |
| 덱    | 양방향    | 브라우저 기록, 스케줄링        | 양쪽 끝에서 삽입/삭제 가능,<br>스택+큐 기능 모두 활요               |
| 리스트  | 인덱스 기반 | 배열 기반 데이터 저장, 랜덤 엑세스 | 특정 위치의 데이터에 즉시 접근 가능,<br>순서와 관계없이 자유롭게 삭제/삽입 가능 |
| 트리   | 계층 구조  | 계층적 데이터 표현(파일 시스템)   | 부모-자식 관계를 표헌                                    |
| 그래프  | 연결 관계  | 네트워크 연결, 경로 탐색       | 노드와 노드 간의 관계 표현,,<br>비선형 구조로 순환관계를 포함함.         |


