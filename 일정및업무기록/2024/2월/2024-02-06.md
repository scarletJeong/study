추가로 [DATE 타입에서 숫자 값을 얻을 때 TO_CHAR 보다 EXTRACT 가 더 낫다고 해서](https://www.toolbox.com/tech/oracle/blogs/to-char-versus-extract-043007/),   
TO_CHAR을 EXTRACT로 바꿔볼까 했는데, [DATETIME 타입은 HOUR, MINUTE, SECOND를 추출할 수 없다](https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions059.htm#SQLRF00639)고 한다.

> If HOUR, MINUTE, or SECOND is requested, then expr must evaluate to an expression of data type TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, or INTERVAL DAY TO SECOND. DATE is not valid here, because Oracle Database treats it as ANSI DATE data type, which has no time fields.

출처: [https://blogingming.tistory.com/entry/데이트-타임-칼럼에서-시간만-추출하기-GROUB-BY-피하기](https://blogingming.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%83%80%EC%9E%84-%EC%B9%BC%EB%9F%BC%EC%97%90%EC%84%9C-%EC%8B%9C%EA%B0%84%EB%A7%8C-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0-GROUB-BY-%ED%94%BC%ED%95%98%EA%B8%B0) [What I learned Today:티스토리]


#2
문제에서 DATETIME이라는 타입으로 작성되었기 때문

=> DATE 타입은 날짜만 / TIMESTAMP는 시간 관련된 값

이 두개를 합쳐 놓은게 **DATETIME**인데, EXTRACT를 하기 위해서는 각 타입에 맞게 변경(CAST) 해줘야 한다.

​

그러므로 연도, 월, 일은 DATE로

시, 분, 초는 TIMESTAMP로 변환을 해주어야 함!

**✔ 시간, 분, 초 추출하기**

**컬럼 타입은 TIMESTAMP**

연도 => **EXTRACT**(**HOUR** FROM CAST(DATETIME AS **TIMESTAMP**)) **HOUR**

분, 초는 위에서 HOUR인 부분만 MINUTE, SECOND 로 변경하면 된다.

**[출처]** [[SQL/Oracle] 입양 시각 구하기(1) - 날짜 추출, 날짜 포맷](https://blog.naver.com/smj9030/222420176566)|**작성자** [밈지](https://blog.naver.com/smj9030)


**✔ 계층형 쿼리**

- 테이블에 **계층형 데이터****가 존재하는 경우 이를 조회하기 위한 쿼리**

**- 계층형 데이터**란 동일 테이블에 계층적으로 상위와 하위 데이터가 포함된 데이터를 말한다.

​

**- 계층형 쿼리** 형태

﻿START WITH 조건 CONNECT BY [NOCYCLE] 조건 [ORDER SIBLINGS BY 컬럼];﻿

**[출처]** [[SQL,Oracle] 입양 시각 구하기(2) - 계층형 쿼리](https://blog.naver.com/smj9030/222420215404)|**작성자** [밈지](https://blog.naver.com/smj9030)


#3 
**EXISTS** 함수

```
SELECT *
  FROM SAMPLE1 s1
 WHERE EXISTS ( SELECT * FROM SAMPLE2 s2 WHERE s1.name = s2.name);
```

: ()안에 서브쿼리만 들어갈 수 있음. _특정값은 넣을 수 없다_

: 처리순서    [메인 쿼리] -> [서브 쿼리]

: 서브쿼리에 대한 결과가 **'존재하는지'**만 확인.

: NULL에 대해 **TRUE를 리턴**함.

**IN** 함수

```
SELECT *
  FROM SAMPLE1 s1
 WHERE s1.name IN ( SELECT * FROM SAMPLE2 s2 WHERE s1.name = s2.name);
```

: ()안에 특정값이나 서브쿼리가 들어갈 수 있음.

: 처리순서    [서브 쿼리] -> [메인 쿼리]

: NULL에 대해 **FALSE를 리턴**함. 따라서 **NOT IN을 사용할 때는 NVL로 NULL체크 꼭 해주기 !!**

출처: [https://kongda.tistory.com/29](https://kongda.tistory.com/29) [콩다코딩:티스토리]