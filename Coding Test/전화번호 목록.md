#해시

- [x] 해시
- [x] Map vs HashMap
- [x] contains vs startsWith


`>>` 데이터 구조와 정렬을 활용하면 한 번의 반복문으로도 문제를 해결할 수 있습니다.

### 1. 해시 (Hash)
>	- 입력 데이터를 고정된 크기의 고유 값(해시 값)으로 변환하는 함수
>	- 해시값은 원래 데이터를 식별하는 데 사용.
>	
```
"apple" -> 해시 함수 -> 12345
"banana" -> 해시 함수 -> 67890 
```
>	
>	- 특징
>		- 1. 빠른 데이터 조회
>			- 해시값을 통해 데이터 위치를 즉시 확인가능
>			- 평균 시간 복잡동 :  O(1)
>		- 2. 충돌 가능성
>			- 서로 다른 입력값이 동일한 해시값을 가질 경우 = 충돌(Collision)
>			- 해시함수는 충돌을 최소화함.
>		- 3. 고정된 크기 출력
>			- 입력데이터의 크기에 상관없이 항상 고정된 크기의 값을 반환함.
>	- EX
>		- 해시맵 또는 해시테이블
>			- 데이터 무결성 확인
>				- 파일이나 데이터가 손상되었는지 확인할 때 해시 사용
>			- 비밀번호 저장
>				- 비밀번호를 평문으로 저장하지 않고, 해시값으로 변환해 저장함.
>			- 블록체인


```
전화번호부 문제에서 해시는 다음과 같은 방식으로 사용될 수 있습니다:

1. 전화번호를 해시맵의 키로 저장.
2. 각 번호의 접두사를 확인할 때, 해시맵을 통해 해당 접두사가 이미 존재하는지 빠르게 확인.

예를 들어:

- `phone_book = ["119", "97674223", "1195524421"]`가 주어졌을 때:
    1. 각 번호를 해시맵에 저장:
        `"119" -> 존재 "97674223" -> 존재 "1195524421" -> 존재`
        
    2. 새 번호가 들어오면 접두사인지 해시맵에서 빠르게 확인:
        - `"1195524421"`은 `"119"`로 시작하므로 충돌 확인 가능.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
import java.util.HashMap;

class Solution {
    public boolean solution(String[] phone_book) {
        HashMap<String, Boolean> map = new HashMap<>();

        // 1. 모든 전화번호를 해시맵에 저장
        for (String phone : phone_book) {
            map.put(phone, true);
        }

        // 2. 각 번호의 접두사가 해시맵에 있는지 확인
        for (String phone : phone_book) {
            for (int i = 1; i < phone.length(); i++) { // 접두사는 최소 1자리 이상
                String prefix = phone.substring(0, i); // 접두사 생성
                if (map.containsKey(prefix)) {
                    return false; // 접두사가 존재하면 false 반환
                }
            }
        }

        return true; // 접두사가 없으면 true 반환
    }
}

```


### 2.  **`Map` 인터페이스**와 **`HashMap` 클래스**의 관계
>	1. `Map<String, Object> map = new HashMap<>();`
>		- `Map`은 **인터페이스**
>	2. `HashMap<String, Object> map = new HashMap<>();`
>		- `HashMap`은 그것을 구현한 **클래스**
>	
>	- 변수 타입을 `Map`으로 선언하면, 나중에 다른 `Map` 구현체(예: `TreeMap`, `LinkedHashMap`)로 쉽게 바꿀 수 있는 **유연성**이 생김.
>	- 이는 **다형성**(Polymorphism)의 원칙을 따르는 방식.


```
Map<String, Boolean> map = new HashMap<>();
map = new TreeMap<>(); // 쉽게 다른 Map 구현체로 변경 가능

HashMap<String, Boolean> map = new HashMap<>();
// map = new TreeMap<>(); // 오류 발생! 변수 타입이 HashMap으로 고정됨
```

> 일반적으로 사용하는 Map
> `우리가 자주 사용하는 `Map`은 인터페이스 `Map`을 기반으로 한 구현체.`
> .
> 	- HashMap
> 		- 순서를 보장하지 않음
> 		- 가장 빠른 조회 성능 : 평균 O(1)
> 	- LinkedHashMap
> 		- 삽입 순서를 유지
> 		- 조회 성능은 HashMap과 비슷 (약간 느림)
> 	- TreeMap
> 		- 키를 정렬된 상태로 유지
> 		- 조회 성능 :  O(log n).



### 3. contains vs startsWith
>	공통점 : 문자열에서 특정 패턴을 찾기 위한 메서드
>	.
>	1. contains
>		- 문자열 내에 특정 **부분 문자열(subString)** 이 포함되어 있는지 확인
>		
>		- 문자열의 어디에 위치하든 검색 대상이 포함되어 있으면 true 반환
>		- 부분 문자열을 찾기위한 범용적인 메서드
>	2. startsWith
>		- 문자열이 특정 **접두사(prefix)** 로 시작하는지 확인
>		- .
>		- 문자열의 처음 부분만 확인하므로, 범용성을 떨어지지만 효율적.

|**기능**|**`contains`**|**`startsWith`**|
|---|---|---|
|**비교 기준**|문자열 내에 검색어가 **포함되어 있는지**|문자열이 특정 **접두사로 시작하는지**|
|**검색 위치**|문자열 **전체**에서 검색|문자열의 **앞부분**만 확인|
|**오프셋 사용**|❌|✅ (`startsWith(prefix, offset)` 가능)|
|**효율성**|문자열 전체를 검사하므로 상대적으로 느림|시작 부분만 검사하므로 효율적|


```
String str = "Hello, world!";
System.out.println(str.contains("Hello"));   // true
System.out.println(str.contains("world"));   // true
System.out.println(str.contains("Java"));    // false


String str = "Hello, world!";
System.out.println(str.startsWith("Hello")); // true
System.out.println(str.startsWith("world")); // false
System.out.println(str.startsWith("world", 7)); // true (7번째 인덱스부터 시작)

```